Operating Systems Lectures

What is an OS?
    Software program that sits between the applications and computational hardware
Why OS's important?
    Most applications interact with the OS
Goals of an OS
    Universal
        Provide convenient software interface to hardware resources
        Maximuize utilization of hardware
        Solve Contention
        Provide Services
    Common
        Provide security
            protect against buggy applications/crashes
            control access to your data by others
        Support software development
        Provide standardized software libraries
            Including a standardized user interface
Definitions
Program, stored algorithm or plan of execution
Process, A program that has been loaded into memory and is executing
Thread, a line of execution in a process
Standard OS Services
    Process and thread management
        start a program (become a process and thread)
        Ending a process/thread
        Debugging programs/processes
    File and input/output management
        Organizing bits into meaningful structures: Files
        Providing interfaces for reading and writing to files
        communicating with external devices
        organizing files into directories
    Interprocess Communication (IPC)
        Signals, pipes, network sockets (TCP/IP)
    Process Coordination
        Contention Management == shared access
Interacting the OS
    Users
        via GUI
        via CLI
    Programs
        via functions
            system calls
            API (application programming interface) functions
        via Network Communication
            Message-based
            Connection based

UNIX
Jan 1st 1970, time zero for UNIX
BASH, bourne again shell (/usr/local/bin/bash)
TCSH, enhanced C-shell (/usr/local/bin/tcsh)
Korn, Shell (/bin/ksh)
chsh, changes the shell
user commands, commands that can only be run from the shell and shell scripts
system calls, request for service that causes the normal CPU execution to be interrupetd and control to be given to the OS ex: read and write
What is the shell?
    Unix based user interface
    Text based
    Provides access to all UNIX user level files
        Start programs
        manage running programs (pipes)
        manage I/O to and from programs (redirection)
        Kill programs
Pipes, pass the standard output into the next commands standard input
#!/bin/bash will invoke the shell specified in the file
IF THEN ELIF LOOP
    if command
    then
        command
    elif
        command
    then
        command
    else
        command
    fi
WHILE LOOP
    while command1
    do
        command2
    done
FOR LOOP
    for i in a b c d
    do
         command
    done
Quoting
    Single quotes protect all metacharacters
    Double quotes protect spaces
        Variables are expanded
    Backslash
        protects signle metacharacter like / or $
Trap command, used to catch signals and clean up

Unix File Structure

files, hard links to inodes
inodes, contain all meta-info.. a reference count..pointers to actual file data and identified by inode number 

Modern OS Concepts
The underlying hardware
    OS provides applications access to the hardware in an abstracted manner
    Processor
        Series of registers
            Stores a number
        Program counter
            contains memory address of next instruction of thread
        Stack pointer
            contains memory address of the current thread's stack
        Execution Circuitry
        High Speed Cache
            Connects to RAM (memory) and all other devices
    Memory
        Array of bytes where each has an address
        Temporary storage, slower than the process and cache but faster than a disk
    Persistent Storage
        Magnetic Disk
        Non-volatile memory (flash etc)
        Optical (CD, DVD, BD)
        Slow, but persists without power
    Virtual Memory
        Creates illusion of 
            Exclusive Memory (not shared)
            Unlimited Memory (up to maximum address size)
Concurrency
    Multiple processes executing at the same time
    Greatly increases the efficiency of an OS
        While one process is waiting for I/O another process can use the CPU
Multiprogramming
    More than one process can be ready to execute
    System calls trigger "context switches" which let the next process run
    Process will not execute again until its system call returns
Timesharing
    CPU time split between multiple processes
    Gives illusion that many processes are running at once
Complications
    Concurrently running processes can share data and/or resources
Race Conditions
    flaw in a system or process where the output exhibits unexpected critical dependence on the relative timing of events
If 2+ processes access a resource concurrently you must provide access control with:
Locks
    Only process owning lock may access resource
    many ways to do locking
    locking usually requires support from the OS

UNIX PARADIGM
EVERYTHING IS A FILE
    even directories and hardware devices...processes are not files though
A file is a stream of bytes according to the system programmer
    An array
    Newlines/carriage returns and tabs are all bytes
    Its persistent and stored on a magnetic disk

PROCESSES
Process management is a necessary component of an OS
Process ---
    Instance of executing a program
    Collection of execution resources associated with an executing program
Program vs Process
    Program 
        executable code
    Process
        Running instance of a program
        more than one processes can be concurrently executing the same program code
            will have seperate execution resources
                virtual address spaces, process id
            On modern OS
                some resources will be shared if two process are executing the same program code
    UNIX PROCESS
        Consists of:
            Unique identity PID
            Virtual address space
            Program code and data(variables) in memory
            User, group identity and umask value
            Execution enviroment
                Enviroment varible, pwd
                List of open files
                Description of actions to take on receiving signals
            Resource limits, scheduling priority
Process States
    Running - On CPU
    Waiting - blocked and waitng for IO, timer alarm or signal
    Zombie - Exited and waiting for cleanup
    Runnable - waiting for CPU
Fork
    Child Process gets____from parent:
        Process credentials
        Enviroment
        stack
        memory
        open fd
        close on exec flags
        signal handling settings
        nice value
        scheduler class
        process group ID
        session ID
        current working directory
        file mode creation mask (umask)
        root directory
        resource limits
        controlling terminal
    Child process has unique:
        PID
        different parent process ID
        own copy of fd and directory streams
        process,text, data and other memory locks not inheritied
        process time, in the tms struct
        resource utilizations are set to 0
        pending signals initialized to the empty set
        timers created by timer_create not inherited
        asynchronous input or output operations not inherited
    Child process exits for two reasons
        Completes execution and exits normally
            exit status 0 
            encounter error condition, recognized it and exit with a non-successful exit status
        Killed by a signal
    Parent Checks child exit status for the process to end
Exec
    Run different program
    Short for execute
    replaces the currently running program
    Destroys currently running program
    Does not create a new process, just replace the one its called from
Process Attributes
    Process ID
        Fixed by the kernel
    Process Group ID or Session ID
    Enviroment
        set of text variables used to pass info between shell and a C program
    Current Directory
        files specified are searched for in the current directory
    Real and effective user ids
        How UNIX implements security
        Affects
            access to files and directories
            signals (you can only kill processes you own)
            access to priviledged system calls (nice, chroot)
            resource limits, quotas
    Real and effective group ids
    Process Scheduling priority

KILLING ZOMBIES
    Can only run one process at a time
    WAITING processes are not consuming resources
    RUNNABLE processes 
        number of processes waiting for the CPU only
    Bounding - 
        Memory Bound - process you're running is limited by available RAM
        CPU bound - process you're running is limited by processor speed
    If a process terminates but its parent doesn't wait, it becomes a ZOMBIE
        Zombies stay in the system until they are waited for
    If parent terminates without cleaning up zombies the zombies become ORPHANS
        Orphans are adobted by INIT 
    kfork, kill command
Ampersand means to start in the background


REGEX
    used by many UNIX program (grep, sed, vi, emacs, regexp)
    Libraries for REGEX
        grep (basic)
        /usr/xpg4/bin/grep -E
        Perl
    grep example
        grep "FINDME" fileToSearch
    grep
        filter
        search Globally for lines matching the Regular Expression and Print them
        means Search
    Basic REs --- Operators
        * -- match 0 or more of the previous character
        ^ -- circumflex at the beginning of the RE indicates RE must start at the beginning
        $ -- placed at end of RE, matches the end of the string
        Pattern     Matches
        jon         matches any string that contains Jon
        ^abc        matches any string that starts with abc
        abc$        matches any string that ends with abc
        ^Will George$   matches any string that exactly says Will George
        .           matches any single character
        \.          quotes a special character like . here
        [abc]       matches any one character inside the brackets
        [^abc]      matches any one character except those in brackets
    Ranges
        [a-z]       matches any character from a to z
        [^a-z]      anything but the characters from a-z
    Decisions
        \|          OR operator with \ escape     
        \(word\) \{number\}     Look for patterns that are repeated at least Number times
        \( \)       paranteheses will capture matched string for later use
        \number     allows you to specify string should match the nth pattern that you have captured

Pipes and Redirection (Interprocess Communication (IPC)
    Sharing open files
        Files stay open when you exec to prevent use:
            Close-on-exec
                Tells kernel to close open files on exec because open files are inhertied by child processes (fd is shared) which can cause security issues
                Set for every fd you do not want to share
                Inherited through fork
        I/O redirection
            Pipes: redirectr input and output b/w different processes
            Possible becuase open files are shared across fork() and exec()
            kernel opens stdin, stdout and stderr for every process created
            You can change where the standard IO streams are coming or going after fork() but before exec() using dup2(fd1, fd2)
        Real IPC
            Intermediate/Temporary Files
            Pipes - b/w two processes forked by common ancestor
            FIFOs (named pipes) - two processes on same machine
            SysV message IPC - communication between processes on same machine
                not a simple byte stream
                supports messages categories for priorities
            Sockets- two processes separated by a network
        Between process IPC
            dup2()
            On Same machine?
                temp/intermediate files
                    -writes to disk slow
                    -no good way to track when other processes readt to recieve or send data
                pipes
                    connect an output only fd in one process to an input only fd in another
        Pipe Creation
            1. fd share across fork() and exec()
            2. parent creates pipe which creates two new fd one in and one out
            3. parent forks and execs (parent and child have fds)
            4. Child reads from input fd and parent process writes to output fd
        flow control with read()
            - receives data and return immediately the number of bytes read
            - if no data it will lcok waiting for data and process is suspended
            - system call
        flow control with write()
            - will not return until all data has been written
            - pipe have a size (only so much data can fit)
            - will block until space becomes available as other process reads data from pipe
        fpathconf()
            -determines the size of a pipe
        Closing pipes
            - if process A closes pipe B's read() will return 0
            - if B closes input pipe write will return -1 and errno in A will be set to EPIPE
            - A will be sent SIGPIPE signal


Signals
    Kernel intiates contact with a user process using SIGNALS
    Uses:   
        Process has done something wrong
            SIGBUS = bus error (invalid memory address)
            SIGSEGV = segmentation fault
            SIGFPE = floating point error
            SIGILL = trying to execute an illegal machine instruction
            SIGSYS = executing an illegal system call
        timer has expired
            If you want to wait you can do so with wait() ..consumes resources
            Or tell kernel you want to be notified when time passes
            SIGALARM - alarm(), ualarm(), sleep()
            SIGCHILD, when called parent process can call wait() or waitpid()
        child has completed executing
            SIGCHILD
        event associated with the terminal has occurred ex:ctrl-c
        Process on the other end of communication has gone away
        Suspend and resume execution of process
        Terminate process
            SIGTERM 15
            SIGKILL 9
        2 user-defined signals
            SIGUSR1
            SIGUSR2
    3 Ways to handle a signal
        1. Ignore it
        2. Take default action
        3. Specify a function that should be called when a type of signal arrives
    sigaction Structure
        First attribute
            SIF_DFL - take default action
            SIG_IGN - ignore the signal
            A pointer to a function that is called when signal is received
    Blocking signals
        Means signal is delayed until it is unblocked
        done with sigprocmask()
    Waiting for a signal
        pause() - suspends process or thread permanently 
    Signals and system calls
        Signals can occur in the middle of a system call
        System calls return an error EINTR
    Sending signals to yourself
        alarm() or raise()
        - can only have one alarm active at a time
