LISTS
    METHOD          USE             Explanation
    append          l.append(item)
    insert          l.insert(index ,item)
    pop             l.pop()
    pop             l.pop(index)
    sort            l.sort()
    l.reverse       l.reverse()
    del             del l[index]
    count           l.count(item)
    remove          l.remove(item)


LIST OPERATIONS BIG-O PYTHON
Grow List                               Big-O
    append                              O(1)    first
    concatenate                         O(n)    last
    list comprehension                  O(1) .. 2nd
    range based assignment              O(1) .. fastest
Pop
    pop end                             O(1)
    pop beginning                       O(n)    .. has to shift all elements
    pop middle                          O(n)    .. has to shift all elements behind it
Get
    index[i]                            O(1)
Set         
    index(i)                            O(1)
Insert
    insert(i, item)                     O(n)
Delete
    del                                 O(n)
Iteration                               O(n)
contains(in)                            O(n)
getSlice[x:y]                           O(k)
del slice                               O(n)
set slice                               O(n+k)
reverse                                 O(n)
concatenate                             O(n)
sort                                    O(n log n)
multiply                                O(nk)


STRINGS
    Lists are mutable Strings and Tuples are not
        You can modify a list with by using indexing and assignment, which you can't do with a string 
    
    Method          Use             Explanation
    center          s.center(w)
    count           s.count(item)
    ljust           s.ljust(w)
    lower           s.lower()
    rjust           s.rjust(w)
    find            s.find(item)
    split           s.split(char)

SETS
    Operators       Example
        in          x.in(set)          
        len         len(set)
        |           set1 | set2     Retuerns all elements in both sets
        &           set1 & set2     Returns all elements in both in set1 and 2
        -           set1 - set 2    Returns all elements in set1 not in set2
        <=          set1 <= set2    Are all elements of set1 in set 2

        -Sets are heterogeneous, immutable python data objects, each item unique
        - declared with curly braces rather than []

    Method              Use                     Explanation
        Union           set1.union(set2)        new set with all elements of both
        intersection    set1.intersection(set2) new set with only common elements
        difference      set1.difference(set2)   new set with only items in 1 and not 2
        issubset        set1.issubset(set2)     if all elements are in 1 and not 2
        add             set1.add(item)          add item to set
        remove          set1.remove(item)       remove item from set
        pop             set1.pop()              remove arbitrary element from set
        clear           set1.clear              remove all elements


DICTIONARY
    Operators           Use
    []                  d[key]
    in                  key in d
    del                 del d[key]
    :                   key:value

    - declared with curly braces
    - comma delimited key:value pairs

    Method              Use                     Explanation
        keys            d.keys()                returns all keys
        values          d.values()              returns all values
        items           d.items()               returns key value pairs
        get             d.get(key)              returns value associated with key or none
        get             d.get(key, alt)         returns k or alt if key doesn't exist


DICT OPERATIONS BIG-O PYTHON
Copy                O(n)
get item            O(1)
set item            O(1)
delete item         O(1)
contains (in)       O(1)
iteration           O(n)




INPUT/OUTPUT

userName = input("input prompt")
    - input function will always be a string and user must convert it to determined type
        user_radius = input("Enter radius")
        radius = float(user_radius)

    String Formatting
    PRINT FUNCTION
        - takes one or more arguments then outputs them using a single blank a default sep
        - change sep by using sep="new sep" 
        - each string ends in new line but can be changed using end="new end"

    FORMATTED STRINGS
        String formatting characters
            Character           Output Format
                d,i                 Integer
                u                   unsigned int
                f                   float m.fffff
                e                   float as m.ffffe+/-x
                E                   float as m.ffffE+/-x
                g                   Use %e for exponents less than -4 or greater than +5 otherwise %f
                c                   Single char
                s                   String
                %                   literal
            Modifier        use         Description
                number      %20d            put value in field of length 20
                -           %-20d           left-justify in field of length 20
                +           %+20d           right-justify in field of length 20
                0           %020d           leading zero-fill in field length of 20
                .           %20.2f          field length 2 with 2 chars to the right like "     4.00
                (name)      %(name)d        get value using the name as the key
        Example: print("%s is %d years old." % (name, age) can also be: 
                 print(age, "is", age, "years old.")
            Method
                format()
                
CONTROL STRUCTURES

while loop:
    while condition:
        action

    while condition and not condition:
        action
for loop:
    for item in list/string/tuple:
        action

    for item in range(num)
        action
if else:
    if condition1:
        action
    else
        action

list comprehension
    for x in range(1, 11):
        sq_list.append(x*x) is equivalent to sq_list = [x * x for x in range(1,11)]

    same for only odd values:
    sq_list =  [x * x for x in range(1,11) if x % 2 != 0]
    or
    [ch.upper() for ch in 'comprehension' if ch not in'aeiou']

Exceptions
    if adverse condition:
        raise RuntimeError("Error Message")
    else:
        action

    try:
        action with potentional adverse condition
    except:
        message outlining condition
        alternate action?

FUNCTION DEFINTIONS
    def square(n):
        return n ** 2

ABSTRACT DATA TYPES
    STACK
        Operations                  Python Implementation     
            s.is_empty()
            s.push(item)            Append used to add to back rather than insert because O(1) vsO(n)
            s.pop()                 Remove is from back rather than front because O(1) vs O(n)
            s.peek()
            s.size()

        Example Problems:
            Balanced Symbols "{[(" ")]}"
            Coverting Decimal to Binary or Hexadecimal or Octal
            infix, prefix and postfix expressions conversions
    QUEUES
        Operations                  Python Implementation
            q.is_empty()
            q.enqueue(item)         Uses insert rather than append so O(n)
            q.size()
            q.dequeue()             Uses pop so O(1)
        Example Problems:
            Hot Potato
            The Josephus Problem
            Printing Tasks          
                Printer class keeps track if busy and of time
                Task class gives random number of pages, time stamp, and wait time
    DEQUES
        Operations                  Python Implementation
            d.is_empty()
            d.add_rear(item)        O(n)    rear is at position 0, so it uses insert
            d.add_front(item)       O(1)    last item so it uses append
            d.size()    
            d.remove_rear()         O(n)    d.pop(0) .. removes 1st item
            d.remove_front()        O(1)    removes last item
        Example Problems:
            Palidrome Problem
                remove and compare first and last and if they are equal continue until size = 1 or 0

LISTS
    UNORDERED LIST
        Operations                  Python Implementation
            add(item)               O(1) .. adds item to front of list and changes head to new item
            remove(item)            O(n)
            search(item)            O(n)
            is_empty()              O(1)
            size()                  O(n)        uses traversal
            append(item)            O(1)
            index(item)             O(n)
            insert(pos, item)       O(n)
            pop()                   O(1)
            pop(pos)                O(n)        uses traversal with current and previous nodes
        Linked List
            Node Class
                class Node:
                    def __init__(self, data)
                        self.data = init_data
                        self.next = None
                    def get_data(self):
                        return self.data
                    def get_next(self):
                        return self.next
                    def set_data(self, new_data):
                        self.data = new_data
                    def set_next(self, new_next):
                        self.next = new_next
            None reference value will denote that there is no next
    ORDERED LIST
        Operations                  Python Implementation
            add(item)               O(n) needs additional reference called previous two steps
            remove(item)            O(n)
            search(item)            O(n) ... but can stop earlier due to order
            is_empty()              O(1)
            size()                  O(n)
            index(item)             O(n)
            pop()                   O(1)
            pop(pos)                O(n)


RECURSION
    Method of solving problems that involes breaking a problem down into smaller and smaller subproblems
    Example Problems:
        Calculating sum of a list of numbers
            use lots of paranthesis to create an order of operations
            
            def list_sum(num_list):
                #base case
                if len(num_list) == 1:
                    return num_list[0]
                #recursive call
                else:
                    return num_list[0] + list_sum(num_list([1:])
        Convert an Integer to a string in any base
            Base Case: Reduce original number to a series of single digit numbers
            Convert single digit number to a string using a lookup
            Concatenate the single digit strings to form the final result
        Function to take a string and return true if it is a palindrome

    Solving a smaller problem until it can't get any smaller then piece together the solutions

    THREE LAWS OF RECURSION
        1. A recursive algorithm must have a base case
        2. A recursive algorithm must change its state and move toward the base case
        3. A recursive algorithm must call itself, recursively
    
    STACK FRAMES
        When a function returns the return value is left on top of the stack for the calling function to access

    VISUALISING RECURSION
        
