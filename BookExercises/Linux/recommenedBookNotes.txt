CHAPTER 10 CASE STUDY 1: UNIX, LINUX AND ANDROID
    Other Variations of UNIX
        AIX
        FreeBSD
        HP-UX
        SCO UNIX
        System V
        Solaris
    Was pet project of Ken Thompson
    UNICS - (Uniplexed Information and Computing Service)
10.2 LINUX OVERVIEW
    -Principle of least surprise: Let everything be simple, elegant and consistent
    -Every program should do just one thing and do it well
    -Avoid useless redundancy
    10.2.2 Interfaces to Linux
        User Interface --> Library Interface --> System Call Interface
        Users--> Standard Utility Programs(shell, editors) --> Standard Library (open, close, read, write, fork) --> Linux OS (process management, memory management, I/O) --> Hardware (CPU, memory)
        |---------------------User MODE-------------------------------------------------------------------------|---------------------------Kernel Mode-------------------|

       - SYSTEM CALLS
            - READ, WRITE, OPEN, CLOSE, FORK etc
            - Programs make system cals by putting arguments in registers or on the stack and issuing trap instructions to switch from user to kernel mode
            - There is no way to write a TRAP instruction in C but a library is provided with one procedure per system call
            - Procedure are written in assembly but can be called from C
                - each first puts its arguments in the proper place then executes the trap instruction
            - The library interface NOT the system call interface is specified by POSIX 
            - POSIX = operating system standards 1003.2
        - Library Calls
            - command processor (shell), compilers, editors, text-processors and file manipulation utilities
        - User interface
            - Similar to the first GUIs with an added Mouse oriented keyboard interface rather than keyboard oriented
            - Popular Desktop Enviroments for Linux
                - GNOME (GNU Network Object Model Enviroment)
                - KDE (K Desktop Enviroment)
            - GUIs supported by X Windowing System or X11 or X
                - Defines communication and display protocols for manipulating windows on bitmap displays
                - X Server controls devices like keyboard, mouse and screen
                - X redirects input to or accepts output from client program
                - Can be started via command line, but is typically started during the boot process by a display manager
                - xterm = terminal emulator 
    10.2.3 THE SHELL
        Command line interface
        - when a user types a command line
            -Shell extracts first word
            - assumes word is a program
            - searches for program
            - runs programs
            - suspends itself until the program terminates
        - flags - optional value
        - magic characters or wildcards
            - * = all possible strings
            - ? = matches any one character
            - [ape]* = matches all files beginning in 'a' 'p' or 'e'
        - When it opens shell automatically has access to a file called Standard Input, Standard Output and Standard Error
        - CTRL-D = end of file
        < - redirect standard in
        > - redirect standard out
        - Filter = program that reads from stdin and writes to stdout
        - pipe symbol 
        - Pipeline - collection of commands connected by pipe symbols
        - To run a process in the background follow it's command with an &
        - Files containing shell commands are called shell scripts
    10.2.4 LINUX UTILITY PROGRAMS
        Six Categories
        1. File and Directory Manipulation Controls
            cp
            mv
            mkdir
            rm
            chmod
            rmdir
            cat
            ls
        2. Filters 
            grep
            sort
            head
            tail
            cut 
            paste
            od, convert binary input to ASCII text in octal, decimal or hexadecimal
            tr, character translation (like from lower to upper case)
            pr, format output for printer
        3. Program Development Tools, such as editors and compilers
            gcc, calls the C compilier
            ar, collects library procedures into archive files
            make, used to maintain large programs whose source code consists of multiple files
    10.2.5 Kernel Structure
        Structures
        Kernel sits on hardware and enables interactions with I/O, Memory and conrols CPU access
            SYSTEM CALLS -- All systems calls come here causing a trap which switches the execution from user to protected kernel mode then passes control to the I/O., Process or Memory Managment
                I/O Component - all components responisble for interacting with devices, performing network and I/O operations
                    -Virtual File System --- HIGHEST LEVEL 
                        -Terminals 
                            -- character device drivers (lowest level)
                                - Seeks and Random Access not allowed
                                    -Can be used to get every keystroke
                                        -tty (Raw Terminal I/O)
                                    -Or can be line oriented
                                        - users must enter whole line before sending it to program
                        -Sockets--Network Protocols
                            --Network Device Drivers (lowest level) - (technically character devices)
                                - Most linux systems contain ful functionality of a hardware router within kernel
                                - Above hardware is IP, TCP, Application layer protocols (with sockets(Top Layer))
                                - allows for programs to create sockets for particular networks and protocols
                                - Gets back a fd for each socket to use later
                        -File Systems--
                            Linux has multiple file systems coexisting
                            Generic Block Layer
                                Provides an abstraction used by all those file systems to hide architectural differences in hardware devices
                                --I/O Scheduler
                                    Responsible for ordering and issuing disk-operation requests to conserve wasteful disk head movement
                                    --Block Device Drivers (lowest level) 
                                        - Seeks and Random Access Allowed
                Memory Management Component
                - Maintains virtual to physical mappings, maintains a cache of recently accessed pages and implements page-replacement and on-debmand bringing in new pages of needed code and data into memory
                    - Virtual Memory
                    - Paging page replacement
                    - Page Cache
                Process Management Component
                - Creates and terminates processes
                    - Signal Handling
                    - Process / Thread creation and Termination
                    - CPU Scheduling
            INTERRUPTS
                - Primary way for interacting with devices
            DISPATCHER
                - Occurs when the interrupt happens
                - Stops the running process, saves its state in the kernel, starts the correct driver
        4. Text Processing
        5. System Administration
        6. Miscellaneous


10.3 PROCESSES IN LINUX

10.3.1 Fundamentals
    - Each process runs a single progra and has a single thread of control
    - Daemon - background process
    - cron daemon - wakes up once per minute to check if there is work ti di
    Process Creations
        - fork system call creates exact copy
        - parent and child
        - each have their own memory images
        - if parent or child changes any variables they wont be visible to the child and vice versa
        - Fork system call returns a 0 to the child and the child's PID to the parent..both check the return value then act
        - getpid = system call that provides childs PID to child
    - Processes communicate via pipes
        - when a process tries to read from an empty pipe it is blocked until data is available
    - Processes also communicate via software interrupts or signals
        - When signal arrives control goes to the handler, when handler finishes control goes back
        - A process can only send signals to members of its process group
            Process group - parent and ancestors, siblings and children
            - A process can send a signal to all members with a single system call


10.3.2 Process Managment System Calls in Linux
    After fork and the return of the child PID to the parent waitpid system call occurs
    --waitpid system call --
        - three parameters
            1. allows the caller to wait for a specific child, if it is -1 any child will do
            2. Address of a variable that will be set to the child's exit status
            3. Determines whether the caller blocks or returns if no child is already terminated
    --execve system call --
        - three parameters
            1. name of the file to be executed
            2. a pointer to the argument array
            3. a pointer to the enviroment array
        -main(argc, argv, envp)
            - argc = count of cl items
            - argv = pointer to array
            - envp = pointer to env array
    -- exit() --
        - if child exits and parent has not waited then zombie
    -- alarm(seconds) --
        a process may need to do something after a specific time period at which point a sig alarm is used
        Only one alarm can be run at a time
    -- pause() -- 
        Only call with alarm set
        Suspends process until next signal which is done by the alarm

    -- PROCESS SYSTEM CALLS --
    pid = fork() -- create a child process identical to parent
    pid = waitpid(pid, &statloc, opts) -- wait for a child to terminate
    s = execve(name, argv, envp) -- replace a process' core image
    exit(status) -- terminate process execution and return status
    s= sigaction(sigm &act, envp), define action to take on signals
    s= sigreturn(& context), return from a signal
    s= sigprocmask(how, &set, &old), examine or change the signal mask
    s= sigpending(set), get the set of blocked signals
    s= sigsuspend(sigmask), replace the signal mask and suspend the process
    s= kill(pid, sig), send a signal to the process
    residual = alarm(seconds), set the alarm clock
    s= pause(), suspend the caller until the next signal

10.3.3 IMPLEMENTATION OF PROCESSES AND THREADS IN LINUX
    - Kernel represents processes as tasks via task_struct
    - A process descriptor of type task_struct is resident in memory at all times
     -- task_struct contains--
        - info needed for the kernel's managment of all processes
            - scheduling parameters
            - lists of open file descriptors etc
        - descriptor and memory for the kernel mode stack for the process are created upon process creation
    - kernel organizes all processes in a doubly linked list of task structures
    - PID is mapped to address of the TASK STRUCTURE for immediate access
    - TASK STRUCTURES -
        - contain pointers to other DS or segments like those containing open files
        - some segments related to user-level stucture (can be swapped or paged out to preserve memory)
    - INFORMATION IN PROCESS DESCRIPTOR -
        1. Scheduling parameters - niceness CPU time consumed, time sleeping
        2. Memory Image - pointers to text, data and stack segments or page tables, if text is shared it points to shared text table
        3. Signals - masks showing which signals are being ignored, which are being caught, which are blocked etc.
        4. Machine Registers - when trap to kernel, machine registers are saved here
        5. System call state - info about current system call, includes parameters and results
        6. File Descriptor Table - fd is used as an index to locate in-core data structure (inode)
        7. Accounting - pointer to a table that tracks user and system CPU time by process, some systems impose limits
        8. Kernel Stack - fixed stack for use by the kernel part of the process
        9. Misc - current state, event being waited for, time until alarm, PID, PID or parent, user and group id


    PROCESS CREATION IN LINUX
        0. fork syste call is executed
        .5 calling process traps to the kernel and creates task structure and other data stuctures like Kernel mode stack and a thread_info structure
        1. new process descriptor and user area are created for the child process and filled in by parent
        1.2 Linux looks for an available PID and updates PID hash-table entry to point to new task structure (process descriptors may be chained)
        2. Child is given a PID
        3. Child memory map is set up
            -- childs page tables point to parents as read only.. 
            -- if a write is attempted  then kernel allocates a new copy so no extra memory taken
            -- called COPY ON WRITE
        4. Child is given shared access to parent's files

        5. Childs registers are set up and it is ready to run
        6. Code running in child does an exec() system call giving command name
        7. kernel finds and verifies the executable file
        8 . Kernel copies the arguments and enviroment string and release the old address space and its page tables
        9. new address space is created and filled in
            1. new page tables set up to indicate no pages are in memory except for a stack page
            2. A page fault will occur which will cause the first page of code to be paged in from the executable file
            3. Args and enviromental strings copied to new stack
            4. signals reset
            5. registers initialized to all zeros
 
LS COMMAND ON PAGE 743!!!

Threads in linux
- Classically when a new thread was created the original threads and the new one shared everything but the registers
    - specifically
        - fd for open files
        - signal handlers
        - alarms
        - other global properties were per process, not per thread
-Clone system call - made it possible for for each aspect to be process or thread specific
    pid = clone(function, stack_ptr, sharing_flags, arg)
    - creates new thread in current or new process
        - if current it shares address space and each write is available to all other threads in the process
        - if address space not shared new thread gets exact copy of address space but new writes not visible
    - new thread gets its own private stack initialized to stack_ptr
    - new thread begins executing at function with arg as its only parameter
    - sharing flags parameter
        - determines whether the new thread copies some data stucutre or shares it with the calling thread
- A linux program that takes advantage of this is no longer portable to UNIX
- UNIX means 1 PID per process regardless of threading. Linux has a TID
    - if precess is started that shares nothing with its creator then PID is set to a new value, otherwise the task gets a new TID but inherits the PID...so all threads has same PID as first


10.3.4 Scheduling in Linux
    Linux threads are Kernel Threads so scheduling based on threads NOT processes

    Classes of Threads
        1. Real - time FIFO
            - highest priority
        2. Real time round robin
            - have time quanta associated with them...so each is run for its quantum
        3. Time sharing
   -- nice system call --
    Better than normal service is -1 to -20

   --runqueue - data structure used by the scheduler to track all runnable tasks in the system
   O(1) Scheduler - able to perform task managment operations in constant time independent of total number of tasks on system
        -Two arrays = active and expired
        - selects task from the highest priority list in active 
            -if quantum expires move to expired
            - if blocked via I/O event - placed back in active, timeslice decremented then placed in expired
            - when no tasks in active, swap pointers so expired become active
    -Dynamic Priority 
        1) reward interactive threads
        2) Punish CPU hogs
    - The heuristics used to determine interactivity of a task and priority level subsequently were complex and imperfect which caused poor performance for interactive tasks

Completely Fair Scheduler (CFS) - default scheduler for non-real time tasks
    - uses red/black tree as the runqueue data structure
        - tasks ordered based on time they spend running on the CPU
        - CFS schedules task with lowest runtime, typically leftmost node
        - periodically checks against current leftmost node
        - if more than the task will be placed in appropriate place in tree and CPU will be given the new leftmost node
        - To account for niceness CFS changes the virtual time passes so lower priority tasks have time run quicker so they are reinserted sooner
        - selecting a node is done in constant time and inserting a task is done in O(log n) time
-->Scheduler only considers runnable tasks
-->Nonrunnable or waiting tasks are places in the waitqueue
    - a waitqueue is associated with each event tasks may wait on

10.3.5 BOOTING LINUX
    1. BIOS perform Power On Self Test (POST)
    2. First sector of the boot disk MBR (Master Boot Record) is read into a fixed memory location and executed
        2.1 Contains a small 512 byte program called boot from the boot device
        2.2 boot program copies itself to a fixed high memory space to free up low memory space for the OS
    3. boot opens the bootloader or GRUB
    4. boot reads in th eoperating system kernel and reads into it
    5. The kernel:
        5.1 sets up the kernel stacks
        5.2 identifies the CPU type
        5.3 Calculates amount of RAM
        5.4 Disabes interrupts
        5.5 Enables the MMU 
        5.6 Calls the C-Language main procedure to start the main part of the program
    6. Kernel data structures are allocated
        6.1 Like the page cache and page data structures...each depend on amount of RAM available
    7. System begins autoconfiguration based on I/O devices and other devices it does this with dynamic loading of devices
        7.1 Dynamic device loading is when a single binary is shipped with divergent configurations which automatically loads drivers it needs
    8. Start init by setting up its stack then running it
    9. Init checks flags to see if it is single or multiuser
        9.1 If single user then it executes the shell and waits for the process to exit
        9.2 If mulit user it executes system initialization shell script and does fsck, mounts additional file systems, starts the daemon processes
            9.2.1 reads etc/ttys (lists terminals and their processes)
            9.2.2 For each terminal it forks off a copy of itself then executes getty
                9.2.2.1 Getty sets the line speed then displays login: on the terminals screen to get users login
                9.2.2.2 After login getty terminates by executing /bin/login
    10. Login program asks for password, encrypts it and checks it against /etc/passwd and if correct replaces itself with the users shell


10.4 MEMORY MANAGEMENT IN LINUX
10.4.1 Fundamental Concepts
    Each process has an address space with three parts:
        Text
            Contains machine instructions that make executable code
            Produced by the compiler and assembled by translation
            Normally read-only
        Data
            Contains storage for all variables, strings, arrays and other data
            Two parts
                Initialized - contains varibles and compiler constants
                unitialized - known as BSS (block started symbol)
            Data segment can change - can grow and shrink dynamically
            System call brk allows a program to set its memory
            Range of dynamically allocated memory areas in the process is called the heap
        Stack
            Starts at top of address space and grows down
            If stack grows below then hardware fault occurs and the OS lowers the bottom of the stack by one page
            At program start stack is not empty, it contains env variables and command line used to invoke it
                So program can easily parse its arguments
            Processes in Linux can access file data through memory mapped files
                - makes it possible to map a file onto a portion of the processes address space which makes random access easier
                - two or more processes can map in the same file at the same time -- writes to one are immediately available to the other
10.4.2 MEMORY MANAGEMENT SYSTEM CALLS IN LINUX
    POSIX does not specify system calls for memory management
    Linux does however
        s = bkr(addr) ... changes the data segment size
        a = mmap(addr, len, prot, flags, fd, offset) ... maps a file in
            addr is the addresss the file is mapped (must be a multiple of the page size)
                if 0 the system determines the address
            len is how many bytes to map
            prot is the protection (read, write, execute)
            flags -- private or sharable and whether adr is a requirement or hint
            fd -- file descriptor
            offset -- where in the file to begin mapping
        s = unmap(addr, len) ... unmaps a file
10.4.3 MEMORY MANAGEMENT IMPLEMENTATION
    Each process gets 3 GB of virtual space  and 1 GB reserved for page tables and other kernel data on 32 bit machine
    64 bit machines only up to 48 bits used for addressing meaning a limit of 256 TB for the size of addressable memory 64 - 48 = 16 split between kernel and user meaning 128 each per process
        - address space created on exec system call
    Physical Memory Management
        Memory Zones:
            1. ZONE_DMA and ZONE_DMA32
                pages used for DMA from 0-16 MB on 32 bit 
            2. ZONE_NORMAL
                regularly mapped pages
            3. ZONE_HIGHMEM
                pages with high-memory addresses which are not permanently mapped anything above 896MB in x86 systems
    Main Memory in Linux has three parts
        First two - both pinned in memory and never paged out
            Kernel - maintains a map of the main memory and use of physical memory in the system
                keeps an array of page_descriptors call mem_map
                    page_descriptor
                        contains a pointer to the address space it belongs to
                zone descriptors for each zone
                node descriptor - used to differentiate between physical memory on different nodes
            Memory Map
    Memory Allocation Mechanisms
        - Page Allocator - main mechanism for allocating new page frames of physical memory
            - operates using the buddy algorithm
            - buddy algorithm
                - take contigous memoory of 64 pages, round up request to closest power of two (so 7 is 8 or 14 is 16), divide lower piece by powers of two until desired pages is reached
        - slab allocator
            - takes chuns using the buddy algorithm then carves slabs from them and manages the smaller units separately
        - vmalloc
            - used when memory needs to be allocated contiguosly in virtual space but not physical
10.4.4 Paging In Linux
    PAGE = main memory management unit
        - alll memory-management components operate on a page granularity
        - Basic Idea
            - a process need not be entirely in memory to run
        - Implemented by:
            The Kernel
            The Page Daemon - process 2 
                - if it sees the list of free memory pages are two low it starts freeing pages
        - at boot time init starts up a page daemon for each meory node and configures them to run periodically called:
            kswapd
                - checks to see if there are enough free pages available, if there is enough memory it goes back to sleep else:
                    - reclaims up to 32 pages (limit is to control I/O pressure)
                    - first tries easy pages then the harder ones
                        - easy = discardable and unreferenced
                            - pages with backing store which have not been referenced recently
                            - user pages
                    - if page is invalid, absent from memory, shared, locked in memory or being used for DMA it is skipped
                - During reclaimation pages are oved between active and inactive and referenced or not
                - if inactive flag and unreferenced flags are set then the pages are set for eviction
       - pdflush
            -set of background daemon threads
            - either wake up to write back to disk very old pages or are explicitly awakened by the kernel when memory levels fall below a certain threshold

10.5 INPUT/OUTPUT IN LINUX
10.5.1 Fundamental Concepts
    I/O Devices include disks, printers, networks
    - Integrated into the file system as special files
        -Two Types
            - Block Files
                - consists of a sequence of numbered blocks
                - each block can be individually addressed and accessed
            - Character Files
                - used for devices that input or output a character stream
                - Character special files can be customized to make system calls that are not permitted in block files
        - Each special file has a device driver
            - major device number - for identification
            - if driver controls multiple devices like two disks of the same type then it has a minor device number too
            - some drivers control multiple devices like /dev/tty controls the keyboard and the screen and is regarded as a signel device the terminal
    - each devices is assigned a path name in /dev
        - disk = /dev/hd1
        - printer = /dev/lp
        - network = /dev/net
        - Can be treated like regular files so cp file /dev/lp will send that file to the printer if the user has access to /dev/lp
10.5.2 Networking
    Socket is the key -- analogous to mailboxes and telephone wall sockets in that they allows users to interface to the network
        - Sockets can be created and destroyed dynamically
        - Sockets supports a specific type of networking specified on creation:
            1. Reliable connection-oriented byte stream
                -- allows tow processes on different machines to establish a pipe between them
            2. Reliable connection- oriented packet stream
                -- preserves packet boundaries
                    - Type 1 and Type 2 
            3. Unreliable packet transmission
        - Once socket have been created on both source and destination computers a connection can be established between them
            - One makes a listen call
            - The other makes a connect call
10.5.3 INPUT/OUTPUT SYSTEM CALLS
    - Used to either get or set the terminal speed ir setting and reading back all the special characters used for erasing characters and lines, interrupting processes etc.
    SYSTEM CALLS:
        s = cfsettospeed(&termios, speed) -- set output speed
        s = cfsettispeed(&termios, speed) -- set input speed
        s = cfgettospeed(&termios, speed) -- get output speed
        s = cfgettispeed(&termios, speed) -- get input speed
        s = tcssetattr(fd, opt, &termios) -- set the attributes
        s = tcgetattr(fd, &termios) -- get the attributes

10.5.4 Implementation of I/O in Linux
    - Implemented by a collection of drivers
    - Drivers function
        -- isolate the rest of the system from the hardware
    - When user accesses the special file
        - 1. file system determines the major and minor device numbers and whether it is block or character
        - 2. Major number used to index into one of two internal hash tables containing data structures for character or block devices
        - 3. Structure contains pointers to perform procedures to call on the device like read, write, open etc. with minor device as parameter
    - All character devices have the following functions/ procedures ...though not all use them
        - Open
        - Close
        - Read
        - Write
        - loctl
        - Other
    - Driver split into two parts both part of the Kernel and run in Kernel mode
        - Top half - runs in context of the caller and interfaces with the rest of linux
        - Bottom half - runs in kernel and interfaces with the device
    - I/O System separated into two components
        - Handling of block special files
            - cache between disk drivers and file system to prevent disk access that isn't needed
            - if not in cache it is read from disk into cache
            - when a write occurs it goes back to the cache not the disk
            - I/O Scheduler
                - reorders and bundles read/write requests to block devices
        - Handling of Character special files

10.5.5 Modules in Linux
    Loadable modules were the solution to bridging the gap between devices and linux when linux moved from minicomputers to pcs
    - When module is loaded:
        1. It has to be relocated as it is loaded
        2. System has to check to see if the resources the driver needs are available
        3. Any interrupt vector must be set up
        4. The appropriate driver switch table has to be updated to handle the new major device type
        5. Driver is allowed to run to perform any device specific initialization


10.6 THE LINUX FILE SYSTEM
